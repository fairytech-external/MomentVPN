// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target arm64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Moment
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import CryptoKit
import Darwin
import Dispatch
import Foundation
@_exported import Moment
import Network
import NetworkExtension
import OSLog
import Swift
import UIKit
import UserNotifications
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_hasMissingDesignatedInitializers public class MomentConstants {
  public static let MOMENT_NOTIFICATION_KEY: Swift.String
  @objc deinit
}
public enum MomentError : Swift.Error {
  case userDeclinedVPNInstallation
  case vpnStartFailed(underlyingError: any Swift.Error)
  case noUserId
  case authFailed(underlyingError: any Swift.Error)
  case notInitialized
  case noInternetConnection
  case jailBrokenDevice
  case unableToAccessSharedDefaults
  case fetchInfoFailed(underlyingError: any Swift.Error)
}
extension Moment.MomentError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
public enum MatchType {
  case enter
  case cart
  case payment
  public static func == (a: Moment.MatchType, b: Moment.MatchType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RecognitionInfo {
  final public let businessId: Swift.String
  final public let matchType: Moment.MatchType
  final public let timestamp: Foundation.Date
  @objc deinit
}
@usableFromInline
internal struct BatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension Moment.BatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <BaseCollection>(lhs: Moment.BatchedCollectionIndex<BaseCollection>, rhs: Moment.BatchedCollectionIndex<BaseCollection>) -> Swift.Bool where BaseCollection : Swift.Collection
  @usableFromInline
  internal static func < <BaseCollection>(lhs: Moment.BatchedCollectionIndex<BaseCollection>, rhs: Moment.BatchedCollectionIndex<BaseCollection>) -> Swift.Bool where BaseCollection : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = Moment.BatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: Moment.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: Moment.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: Moment.BatchedCollection<Base>.Index) -> Moment.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: Moment.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<Moment.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Moment.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<Moment.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> Moment.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
@objc @_inheritsConvenienceInitializers open class PacketTunnelProvider : NetworkExtension.NEPacketTunnelProvider {
  #if compiler(>=5.3) && $AsyncAwait
  @objc override dynamic public func startTunnel(options: [Swift.String : ObjectiveC.NSObject]? = nil) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc override dynamic public func stopTunnel(with reason: NetworkExtension.NEProviderStopReason) async
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc override dynamic public func handleAppMessage(_ messageData: Foundation.Data) async -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc override dynamic public func sleep() async
  #endif
  @objc override dynamic public func wake()
  #if compiler(>=5.3) && $AsyncAwait
  open func handleRecognitionResult(recognizedInfo: Moment.RecognitionInfo) async
  #endif
  @objc override dynamic public init()
  @objc deinit
}
@_Concurrency.MainActor public func handleMomentNotification(response: UserNotifications.UNNotificationResponse)
@_hasMissingDesignatedInitializers public class MomentServiceManager {
  public static let shared: Moment.MomentServiceManager
  public static func initialize(packetTunnelBundleIdentifier: Swift.String)
  #if compiler(>=5.3) && $AsyncAwait
  public static func isConnectedToOwnVPN() async -> Swift.Bool
  #endif
  public static func isConnectedToOwnVPN(completion: @escaping (Swift.Bool) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  public func start() async throws
  #endif
  public func start(completion: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func stop()
  #if compiler(>=5.3) && $AsyncAwait
  public func getVPNStatus() async -> NetworkExtension.NEVPNStatus?
  #endif
  public func withVPNStatus(completion: @escaping (NetworkExtension.NEVPNStatus?) -> Swift.Void)
  public func setMarketingPushConsent(agreed: Swift.Bool)
  public func setUserId(to userId: Swift.String)
  public func setVPNProfileName(to name: Swift.String)
  public func setVPNServerName(to name: Swift.String)
  @objc deinit
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
  @inlinable internal subscript(safe index: Swift.Array<Element>.Index) -> Element? {
    get {
    return indices.contains(index) ? self[index] : nil
  }
  }
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits ≡ 448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
extension Moment.MatchType : Swift.Equatable {}
extension Moment.MatchType : Swift.Hashable {}
